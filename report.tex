\documentclass[11pt]{article}
\usepackage[margin=1.25in]{geometry}
\usepackage{graphicx,float}
\usepackage{subcaption} % For side-by-side figures

% For labelings/struct descriptions
\usepackage{blindtext}
\usepackage{scrextend}
\addtokomafont{labelinglabel}{\sffamily}

\usepackage{listings} % For source code
\usepackage{algorithm,algorithmicx,algpseudocode} % For algorithms

%opening
\title{Tree Drawing}
\author{Vincent La}

\begin{document}

\tableofcontents
\maketitle

\section{Motivation}
Trees with at most two child nodes are used widely in computer science. The simplicity of their structure easily lends to mathematical analysis about algorithms operating on binary trees. Given the vast utility of this tree, many have tried to define algorithms which draw binary trees.

\section{Reingold-Tillford (1981)}
One classic algorithm used to layout binary trees is described by Reingold and Tillford. 

\begin{figure}[H]
    \includegraphics[width=\linewidth]{"report/tree_2".pdf}
    \caption{A complete binary tree}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}{.5\textwidth}
        \centering
        \includegraphics[width=2in]{"report/figure2".pdf}
        \caption{An example of a tree generated by RT 81}
        \label{fig:fig2}
    \end{subfigure}%
    \begin{subfigure}{.5\textwidth}
        \centering
        \includegraphics[width=2in]{"report/figure4".pdf}
        \caption{Unlike other algorithms, RT 81 draws a tree and its mirror symetrically}
    \end{subfigure}%

    \caption{A reproduction of some figures from RT's original paper}
\end{figure}

\begin{figure}[H]
    \includegraphics[width=\linewidth]{"report/figure2_contours".pdf}
    \caption{The left contour and right contour of the same tree}
\end{figure}

\subsection{Algorithm Description}
\subsubsection{Informal Description}
First, we calculate the displacements of the nodes relative to each other.

\begin{enumerate}
    \item Base Case: Trivial
    \item Apply this algorithm to subtrees via a postorder traversal
    \item For each subtree, merge them horizontally such that they are two units apart horizontally
\end{enumerate}

\subsubsection{Formal Description}
\paragraph{Node Type}
To implement the tree in a programming language, we will need to creature a structure that represents each node in the tree.
\begin{labeling}{alligator}
    \item [left] Pointer to left subtree
    \item [right] Pointer to right subtree
    \item [offset] Offset relative to parent
\end{labeling}

By using offsets relative to a node's parent, as opposed to absolute offsets, we avoid having to reposition all of the nodes in a subtree when the root of that subtree gets moved.

\begin{algorithm}
    \caption{Reingold and Tilford's Algorithm}\label{euclid}
    \begin{algorithmic}[1]
        \Statex Constants:
        \Statex $minsep$: The smallest distance any two subtrees can be separated by [units]
        \Statex
        \Statex Input:
        %\hspace{\parindent}
        \Statex $t$: A binary tree
        \Statex
        
        % Begin Describing Algorithm   
        \Procedure{setup}{$t$}
        \State $cursep = minsep$ \Comment{Used to keep track of how far apart subtrees are}        
        \State setup(t$\rightarrow$left) \Comment{Post-order traversal on tree}
        \State setup(t$\rightarrow$right)
        
        % Begin Push
        \State $left \gets t\rightarrow left$
        \State $right \gets t\rightarrow right$
        \While{left is not NULL right is not NULL} \Comment{We only have to traverse as deep as the shortest subtree }
        \If{$cursep < minsep$} \Comment{Trees too close, so push them apart}
        \State $left\_dist \gets left\_dist + (minsep - cursep)/2$        
        \State $right\_dist \gets right\_dist + (minsep - cursep)/2$
        \State $cursep = minsep$
        \EndIf
        
        % Left->right
        \If{$left \rightarrow right$ not null} \Comment{Traverse left subtree}
        \State $left \gets left \rightarrow right$
        \State $cursep \gets cursep - left.offset$
        
        % Left->left
        \Else
        \State $left \gets left \rightarrow right$
        \State $cursep \gets cursep - left.offset$
        \EndIf
        
        % Right->left
        \If{$right \rightarrow left$ not null} \Comment{Traverse right subtree}
        \State $right \gets right \rightarrow left$
        \State $cursep \gets cursep - right.offset$
        \EndIf
        
        % Right->right
        \If{$left \rightarrow right$ not null}
        \State $right \gets right \rightarrow right$
        \State $cursep \gets cursep - right.offset$
        \EndIf
        
        \EndWhile\label{euclidendwhile}
        
        % Threading
        \If{$left$} \Comment{The left subtree was taller}
        \State Insert a thread from the right-most item of the right subtree to $right$
        \EndIf
        
        \If{$right$} \Comment{The right subtree was taller}
        \State Insert a thread from the left-most item of the left subtree to $right$
        \EndIf
        
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsubsection{Threading}
For every node in a given tree, the algorithm traverses through the left contour of the right subtree, and the right contour of the left subtree. In this traversal, the goal is to find the appropriate number units to separate the trees by. However, for any given node, its right contour may not be contained entirely within the same subtree. Hence, we require "threads", or connections between nodes in different subtrees in order to follow a tree's contour. Per the visualization below, we may think of threads as temporary edges.

\begin{figure}[H]
    \centering
    \includegraphics[width=4in]{"report/figure2_threads".pdf}
    \caption{Threads (dashed) created by the algorithm while traversing the tree in Figure \ref{fig:fig2} }
\end{figure}

\subsection{Algorithm Trace for Complete Binary Trees}
The figures below show the displacements set by the algorithm for each node. From these figures, we can see how the algorithm achieves symmetry between subtrees.

\begin{figure}[H]
    \centering
    \includegraphics[width=4in]{"report/figure2_labels".pdf}
    \caption{Algorithm trace for example tree}
\end{figure}

\begin{figure}[H]   
    \includegraphics{"report/binary_tree_1".pdf}
    \linebreak
    
    \includegraphics{"report/binary_tree_2".pdf}
    \linebreak
    
    \includegraphics{"report/binary_tree_3".pdf}
    \linebreak
    
    \includegraphics[width=\linewidth]{"report/binary_tree_4".pdf}
    \linebreak
    
    \includegraphics[width=\linewidth]{"report/binary_tree_5".pdf}
    \linebreak
    
    \caption{Algorithm trace for complete binary trees of heights 2 through 6}
\end{figure}

\pagebreak

\subsection{N-Ary Tree Drawing}
The algorithm above can also be generalized to trees with $n$ roots.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{"report/ternary_tree_no_label3".pdf}
\end{figure}

\end{document}
